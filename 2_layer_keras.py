# -*- coding: utf-8 -*-
"""2_layer_keras.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pTllSMO3D-zj5A_zwSmEOtN5_cwSA7o4
"""

from keras.models import Sequential
from keras.layers import Dense
import numpy
import scipy.io

from google.colab import drive
drive.mount('/content/drive')

# fix random seed for reproducibility
numpy.random.seed(7)

mat = scipy.io.loadmat('/content/drive/My Drive/4830_final_proj/ELEC4830_Final_project.mat')

Y_raw = mat['trainState']
noNan = numpy.where(numpy.isnan(Y_raw) == False)
Y = Y_raw.take(noNan[1])
# Y = numpy.array([])
# for i in range(0, len(noNan[1]), 10):
#   a = Y_raw[:,noNan[1][i]:noNan[1][i+9]+1]
#   nan = numpy.where(numpy.isnan(a) == True)
#   cnt = numpy.count_nonzero(numpy.isnan(a))
# #   a[:, nan[1][0:int(cnt/2)]] = 0
# #   a[:, nan[1][int(cnt/2):]] = 1
#   a[:, nan[1][0:cnt]] = numpy.linspace(0,1,cnt)
#   Y = numpy.append(Y, a)
# #     print(i)
# Y_raw.shape, Y.shape
# # print(noNan[1][0:25])
# # Y_raw[:,noNan[1][10]:noNan[1][19]+1]
# # numpy.append(Y_raw[:,noNan[1][0]:noNan[1][0+9]+1], Y_raw[:,noNan[1][10]:noNan[1][10+9]+1])
# # a = Y_raw[:,noNan[1][0]:noNan[1][9]+1]
# # nan = numpy.where(numpy.isnan(a) == True)
# # print(a)
# # cnt = numpy.count_nonzero(numpy.isnan(a))
# # a[:, nan[1][0:int(cnt/2)]] = 0
# # a[:, nan[1][int(cnt/2):]] = 1
# # a

# import matplotlib.pyplot as plt
# fig=plt.figure(figsize=(800, 10), dpi= 80, facecolor='w', edgecolor='k')
# plt.plot(Y_raw.T, '.')
# plt.show()

X_raw =  mat['trainSpike']
# X = X_raw[:,noNan[1]]
X = numpy.array([])
prev_data = 10
X = numpy.mean(X_raw[:, noNan[1][0]-prev_data:noNan[1][0]], axis = 1)[numpy.newaxis].T
for i in range(1, len(noNan[1])):
    a = numpy.mean(X_raw[:, noNan[1][i]-prev_data:noNan[1][i]], axis = 1)[numpy.newaxis].T
    X = numpy.append(X, a, axis = 1)
X_raw.shape, X.shape
# a = numpy.mean(X_raw[:, noNan[1][0]-10:noNan[1][0]], axis = 1)[numpy.newaxis].T
# b = numpy.mean(X_raw[:, noNan[1][1]-10:noNan[1][1]], axis = 1)[numpy.newaxis].T
# print(numpy.append(a, b, axis = 1))
# X_raw[:, noNan[1][0]-10:noNan[1][0]]

X = X.T
# Y = Y.T
X.shape, Y.shape

from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state = 42)

from sklearn.preprocessing import StandardScaler  
scaler = StandardScaler()  
scaler.fit(X_train)

X_train = scaler.transform(X_train)  
X_test = scaler.transform(X_test)

X_train.shape, Y_train.shape

from keras.constraints import unit_norm
from sklearn.model_selection import StratifiedKFold
cvscores = []
# define 3-fold cross validation test harness
kfold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
for train, test in kfold.split(X_train, Y_train):
  # create model
  model = Sequential()
  model.add(Dense(128, input_dim=16, activation='relu'))
#   model.add(Dense(64, activation='relu'))
  model.add(Dense(1, activation='sigmoid'))
  # Compile model
  model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
  model.fit(X_train[train], Y_train[train], epochs=200, batch_size=64, verbose=0)
	# evaluate the model
  scores = model.evaluate(X_train[test], Y_train[test], verbose=0)
  print("%s: %.2f%%" % (model.metrics_names[1], scores[1]*100))
  cvscores.append(scores[1] * 100)
print("%.2f%% (+/- %.2f%%)" % (numpy.mean(cvscores), numpy.std(cvscores)))

# # Fit the model
# model.fit(X_train, Y_train, validation_data=(X_test, Y_test), epochs=200, batch_size=64)
# # evaluate the model
# scores = model.evaluate(X_test, Y_test)
# print("\n%s: %.2f%%" % (model.metrics_names[1], scores[1]*100))

X_pred = mat['testSpike'].T
numpy.set_printoptions(threshold=numpy.inf)
y_pred = model.predict_classes(X_test)

from sklearn import metrics
print("Accuracy:",metrics.accuracy_score(Y_test, y_pred))

from sklearn.metrics import confusion_matrix
print(confusion_matrix(Y_test, y_pred))

X_test = mat['testSpike']
X_test.shape

l = 2
X = numpy.array([])
X = numpy.mean(X_test[:, 0: 1], axis = 1)[numpy.newaxis].T
for i in range(2, len(X_test[0])+1):
  if l != prev_data:
#     print(l,i)
    a = numpy.mean(X_test[:, i-l: i], axis = 1)[numpy.newaxis].T
    X = numpy.append(X, a, axis = 1)
    l+=1
  else:
    a = numpy.mean(X_test[:, i-prev_data: i], axis = 1)[numpy.newaxis].T
    X = numpy.append(X, a, axis = 1)
X = X.T
X.shape
# print(X)

X_test = scaler.transform(X)
decodedState = model.predict_classes(X_test)
scipy.io.savemat('/content/drive/My Drive/4830_final_proj/result_nn.mat', mdict={'decodedState': decodedState})

# ts = []
# cnt = 0
# chk = 0
# prev = [1, 1, 0, 1]
# for i in ind:
#     ts.append(y_pred[i])

# for i in range(0, 100):
#     new = ts[0][5*i:5*i+5].T
#     print(new)
#     if numpy.sum(prev) < 3 and numpy.sum(new) > 3:
#       chk +=1
#     prev = new
#     cnt +=1
#     if cnt == 2:
#       print('\n')
#       cnt = 0
      
# print(chk)

# import matplotlib.pyplot as plt
# fig=plt.figure(figsize=(400, 10), dpi= 80, facecolor='w', edgecolor='k')
# plt.plot(y_pred, '*')
# plt.show()

